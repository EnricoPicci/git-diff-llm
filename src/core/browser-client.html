<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>git-diff-llm web client</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 40px auto;
            padding: 20px;
            background-color: #f4f4f4;
        }
        .dropdown-container {
            margin-bottom: 20px;
        }
        select {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
        }
        button {
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        .spinner {
            display: none;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <form>
        <label for="repo-url">Repo URL:</label>
        <input type="text" id="repo-url" name="repo-url" value="https://github.com/EnricoPicci/git-diff-llm">
        <button type="button" onclick="cloneRepo()">Clone</button>
    </form>
    
    <div  id="compareRepoContainer"  style="display: none;">
        <div>
            <label for="compareRepo">Compare with other remote repo</label>
            <input type="checkbox" id="compareRepo" name="compareRepo" onchange="toggleRemoteRemoteUrl()">
        </div>
        <div id="remoteUrlContainer" style="display: none;">
            <label for="secondRepoUrl">Project url:</label>
            <input type="text" id="secondRepoUrl" name="secondRepoUrl">
        </div>
        <div id="secondRepoDirectionContainer" style="display: none;">
            <label>Direction:</label>
            <div>
                <input type="radio" id="fromRepo" name="repoDirection" value="from" onchange="setSecondRepoDirection(this.value)">
                <label for="fromRepo">From</label>
            </div>
            <div>
                <input type="radio" id="toRepo" name="repoDirection" value="to" checked onchange="setSecondRepoDirection(this.value)">
                <label for="toRepo">To</label>
            </div>
        </div>        
        <button id="confirm" type="button" onclick="addSecondRepo()" style="display: none;">confirm</button>
    </div>

    <div class="spinner" id="loadingSpinner"></div>
    
    <div  id="fromTagBranchCommit"  style="display: none;">
        <p>FROM Tag, Branch or Commit</p>
        <div id="fromTagBranchCommit">
            <div class="dropdown-container">
                <label for="fromTags">Tags:</label>
                <select id="fromTags" name="tags"></select>
            </div>

            <div class="dropdown-container">
                <label for="fromBranches">Branches:</label>
                <select id="fromBranches" name="branches"></select>
            </div>

            <div class="dropdown-container">
                <label for="fromCommits">Commits:</label>
                <select id="fromCommits" name="commits"></select>
            </div>
        </div>
    </div>

    <div  id="toTagBranchCommit"  style="display: none;">
        <p>TO Tag, Branch or Commit</p>
        <div class="dropdown-container">
            <label for="toTags">Tags:</label>
            <select id="toTags" name="tags"></select>
        </div>
        <div class="dropdown-container">
            <label for="toBranches">Branches:</label>
            <select id="toBranches" name="branches"></select>
        </div>

        <div class="dropdown-container">
            <label for="toCommits">Commits:</label>
            <select id="toCommits" name="commits"></select>
        </div>
    </div>

    <form id="launchReport" style="display: none;">
        <label for="llm-model">LLM Model:</label>
        <input type="text" id="llm-model" name="llm-model" placeholder="LLM model to use, e.g. gpt-4o" value="gpt-3.5-turbo">
        <p>
        <label for="languages">Programming languanges:</label>
        <input type="text" id="languages" name="languages" placeholder="programming languages to consider, e.g. TypeScript, Java" value="TypeScript, Java, Python">
        <p>
        <button type="button" onclick="generateReport()">Generate Report</button>
    </form> 

    <div id="report"></div>

    <h3>Messages:</h3>
    <div id="messages"></div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>

        // ws is a global variable to store the websocket connection
        let ws = null;
        // tempDir is a global variable to store the temporary directory created by the server when cloning a repo
        let tempDir = '';
        // isFromTag and isToTag are global variables to store if the selected option is a tag
        let isFromTag = false;
        let isToTag = false;
        // second_repo_used_as_from_repo and second_repo_used_as_to_repo are global variables to store if the second repo is used as from or to repo
        // the default is to use the second repo as the to repo
        let is_second_repo_used_as_from_repo = false
        let is_second_repo_used_as_to_repo = true;

        startWebsocketConnection();

        function startWebsocketConnection() {
            ws = new WebSocket('ws://localhost:3000');
            ws.onopen = function() {
                console.log('Websocket connection opened');
            };
            ws.onmessage = function(wsMessage) {
                const message = JSON.parse(wsMessage.data);
                console.log('Message received:', message);

                const messageId = message.messageId;
                if (messageId === 'report-generated') {
                    const report = message.mdReport;
                    fillReport(report);
                } else {
                    // message is generated by the server as an object of type MessageToClient
                    const messageData = message.data;
                    const _message = typeof messageData === 'string' ? messageData : JSON.stringify(messageData);
                    displayMessage(_message);
                }
            };
            ws.onerror = function(error) {
                console.error('Websocket error:', error);
            };
            ws.onclose = function() {
                console.log('Websocket connection closed');
            };
        }

        function sendWebsocketMessage(msg) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(msg);
            } else {
                console.error('Websocket connection is not open');
            }
        }

        async function cloneRepo() {
            const repoUrl = document.getElementById('repo-url').value;
            const loadingSpinner = document.getElementById('loadingSpinner');
            loadingSpinner.style.display = 'block';
            try {
                const response = await fetch('http://localhost:3000/api/v1/clone-repo', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ repoUrl })
                });
                const data = await response.json();
                tempDir = data.tempDir;
                console.log('TempDir:', data.tempDir);
                await populate_From_DropdownsAndSetupInterations();
                await populate_To_DropdownsAndSetupInterations();
                const fromTagBranchCommitContainer = document.getElementById('fromTagBranchCommit');
                fromTagBranchCommitContainer.style.display = 'block';
                const toTagBranchCommitContainer = document.getElementById('toTagBranchCommit');
                toTagBranchCommitContainer.style.display = 'block';
                const compareRepoContainer = document.getElementById('compareRepoContainer');
                compareRepoContainer.style.display = 'block';
                const compareRepoCheckbox = document.getElementById('compareRepo');
                compareRepoCheckbox.checked = false;
                const launchReportForm = document.getElementById('launchReport');
                launchReportForm.style.display = 'block';
            } catch (error) {
                console.error('Error:', error);
            } finally {
                loadingSpinner.style.display = 'none';
            }
        }
        
        async function populate_From_DropdownsAndSetupInterations(gitRemote) {
            // Dropdown elements
            const tagsDropdown = document.getElementById('fromTags');
            const branchesDropdown = document.getElementById('fromBranches');
            const commitsDropdown = document.getElementById('fromCommits');

            // Initial population of dropdowns
            const remoteParam = gitRemote ? `&remote=${gitRemote}` : '';
            const params = `?tempDir=${tempDir}${remoteParam}`;
            populateDropdown(tagsDropdown, `http://localhost:3000/api/v1/list-tags${params}`, 'tags');
            populateDropdown(branchesDropdown, `http://localhost:3000/api/v1/list-branches${params}`, 'branches');
            populateDropdown(commitsDropdown, `http://localhost:3000/api/v1/list-commits${params}`, 'commits');

            // Setup dropdown interactions
            setupDropdownInteraction(tagsDropdown, [branchesDropdown, commitsDropdown]);
            setupDropdownInteraction(branchesDropdown, [tagsDropdown, commitsDropdown]);
            setupDropdownInteraction(commitsDropdown, [tagsDropdown, branchesDropdown]);
        }
        
        async function populate_To_DropdownsAndSetupInterations(gitRemote) {
            // Dropdown elements
            const tagsDropdown = document.getElementById('toTags');
            const branchesDropdown = document.getElementById('toBranches');
            const commitsDropdown = document.getElementById('toCommits');

            // Initial population of dropdowns
            const remoteParam = gitRemote ? `&remote=${gitRemote}` : '';
            const params = `?tempDir=${tempDir}${remoteParam}`;
            populateDropdown(tagsDropdown, `http://localhost:3000/api/v1/list-tags${params}`, 'tags');
            populateDropdown(branchesDropdown, `http://localhost:3000/api/v1/list-branches${params}`, 'branches');
            populateDropdown(commitsDropdown, `http://localhost:3000/api/v1/list-commits${params}`, 'commits');

            // Setup dropdown interactions
            setupDropdownInteraction(tagsDropdown, [branchesDropdown, commitsDropdown]);
            setupDropdownInteraction(branchesDropdown, [tagsDropdown, commitsDropdown]);
            setupDropdownInteraction(commitsDropdown, [tagsDropdown, branchesDropdown]);
        }

        // Function to populate a dropdown
        async function populateDropdown(dropdown, url, dataKey) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                // Clear existing options
                dropdown.innerHTML = '<option value="">Select an option</option>';
                
                // Add new options
                data[dataKey].forEach(item => {
                    const option = document.createElement('option');
                    option.value = item;
                    option.textContent = item;
                    dropdown.appendChild(option);
                });
            } catch (error) {
                console.error('Error fetching dropdown data:', error);
                dropdown.innerHTML = '<option value="">Error loading data</option>';
            }
        }

        // Function to reset other dropdowns when a selection is made
        function setupDropdownInteraction(dropdown, otherDropdowns) {
            dropdown.addEventListener('change', (event) => {
                const srcEl = event.target;
                if (srcEl.id === 'fromTags') {
                    isFromTag = true;
                } else if (srcEl.id === 'toTags') {
                    isToTag = true;
                } else {
                    // If the selection is not a tag and comes from the "from" dropdown, reset the isFromTag flag
                    if (srcEl.id === 'fromBranches' || srcEl.id === 'fromCommits') {
                        isFromTag = false;
                    }
                    // If the selection is not a tag and comes from the "to" dropdown, reset the isToTag flag
                    if (srcEl.id === 'toBranches' || srcEl.id === 'toCommits') {
                        isToTag = false;
                    }
                }
                // Reset other dropdowns
                otherDropdowns.forEach(otherDropdown => {
                    otherDropdown.selectedIndex = 0;
                });
            });
        }

        function toggleRemoteRemoteUrl() {
            const remoteUrlContainer = document.getElementById('remoteUrlContainer');
            const toTagBranchCommitContainer = document.getElementById('toTagBranchCommit');
            const compareRepoCheckbox = document.getElementById('compareRepo');
            const confirmButton = document.getElementById('confirm');
            const launchReportForm = document.getElementById('launchReport');
            const secondRepoDirectionContainer = document.getElementById('secondRepoDirectionContainer');
            if (compareRepoCheckbox.checked) {
                remoteUrlContainer.style.display = 'block';
                // toTagBranchCommitContainer.style.display = 'none';
                confirmButton.style.display = 'block';
                // launchReportForm.style.display = 'none';
                secondRepoDirectionContainer.style.display = 'block';
            } else {
                remoteUrlContainer.style.display = 'none';
                // toTagBranchCommitContainer.style.display = 'block';
                confirmButton.style.display = 'none';
                // launchReportForm.style.display = 'block';
                secondRepoDirectionContainer.style.display = 'none';
                // populate_To_DropdownsAndSetupInterations();
            }
        }
        
        function setSecondRepoDirection(value) {
            if (value === 'from') {
                is_second_repo_used_as_from_repo = true;
                is_second_repo_used_as_to_repo = false;
            } else if (value === 'to') {
                is_second_repo_used_as_from_repo = false;
                is_second_repo_used_as_to_repo = true;
            }
        }

        async function addSecondRepo() {
            const secondRepoUrl = document.getElementById('secondRepoUrl').value;
            // the remote name is the last part of the URL
            const remoteUrlParts = secondRepoUrl.split('/');
            const remoteName = remoteUrlParts[remoteUrlParts.length - 1]; 
            const _body = { tempDir, remoteName };
            _body.remoteUrl = secondRepoUrl;
            console.log('Body:', _body);
            try {
                const response = await fetch('http://localhost:3000/api/v1/add-remote', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(_body)
                });
                const data = await response.json();
                if (is_second_repo_used_as_from_repo) {
                    await populate_From_DropdownsAndSetupInterations(remoteName);
                    await populate_To_DropdownsAndSetupInterations();
                }
                if (is_second_repo_used_as_to_repo) {
                    await populate_To_DropdownsAndSetupInterations(remoteName);
                    await populate_From_DropdownsAndSetupInterations();
                }
                const toTagBranchCommitContainer = document.getElementById('toTagBranchCommit');
                toTagBranchCommitContainer.style.display = 'block';
                const launchReportForm = document.getElementById('launchReport');
                launchReportForm.style.display = 'block';
            } catch (error) {
                console.error('Error:', error);
            }
        }

        function generateReport() {
            const action = 'generate-report';

            const url_to_repo = document.getElementById('repo-url').value;
            let from_tag_branch_commit = document.getElementById('fromTags').value || 
                                            document.getElementById('fromBranches').value || 
                                            document.getElementById('fromCommits').value;
            let to_tag_branch_commit = document.getElementById('toTags').value ||
                                            document.getElementById('toBranches').value ||
                                            document.getElementById('toCommits').value;
            if (isFromTag) {
                from_tag_branch_commit = `tags/${from_tag_branch_commit}`;
            }
            if (isToTag) {
                to_tag_branch_commit = `tags/${to_tag_branch_commit}`;
            }

            const llmModelEl = document.getElementById('llm-model')
            const llmModel = llmModelEl.value
                                            
            const data = {
                tempDir,
                url_to_repo,
                from_tag_branch_commit,
                to_tag_branch_commit,
                url_to_second_repo: document.getElementById('secondRepoUrl').value,
                is_second_repo_used_as_from_repo,
                is_second_repo_used_as_to_repo,
                use_ssh: false,
                promptTemplates: null,
                outdir: tempDir,
                llmModel,
                languages: document.getElementById('languages').value
            }
            const message = JSON.stringify({ action, data });
            sendWebsocketMessage(message);
        }

        function fillReport(report) {
            document.getElementById('report').innerHTML =
                marked.parse(report);
        }
        
        function displayMessage(message) {
            const messagesContainer = document.getElementById('messages');
            const messageElement = document.createElement('p');
            messageElement.textContent = message;
            messagesContainer.insertBefore(messageElement, messagesContainer.firstChild);
        }
    </script>
</body>
</html>